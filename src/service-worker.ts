/// <reference lib="webworker" />
import { precacheAndRoute } from 'workbox-precaching'

declare const self: ServiceWorkerGlobalScope

// Precache all static assets generated by Vite
precacheAndRoute(self.__WB_MANIFEST)

console.log('âœ… Service worker loaded and activated')

// Listen for push events (incoming notifications from server)
self.addEventListener('push', (event: PushEvent) => {
  console.log('ðŸ”” Push event received in service worker')
  
  if (!event.data) {
    console.warn('âš ï¸ Push event received but had no data')
    return
  }

  try {
    const data = event.data.json()
    console.log('ðŸ“§ Push notification payload:', data)

    const notificationOptions: NotificationOptions = {
      body: data.body || 'You have a new notification from PetCare Manager',
      icon: '/vite.svg',
      badge: '/vite.svg',
      data: data.data || {},
      requireInteraction: false,
      tag: data.tag || 'petcare-notification'
    }

    event.waitUntil(
      self.registration.showNotification(
        data.title || 'ðŸ¾ PetCare Reminder', 
        notificationOptions
      )
    )
  } catch (error) {
    console.error('âŒ Error processing push event:', error)
  }
})

// FIXED: Handle notification clicks with proper async handler
self.addEventListener('notificationclick', (event: NotificationEvent) => {
  console.log('ðŸ–±ï¸ Notification clicked:', event.notification.tag)
  console.log('ðŸ“¦ Notification data:', event.notification.data)
  
  event.notification.close()

  // Get the URL to open from notification data
  const urlToOpen = event.notification.data?.url || '/'
  
  console.log('ðŸŽ¯ Target URL:', urlToOpen)

  event.waitUntil(
    // FIXED: Use async IIFE for proper error handling
    (async () => {
      try {
        const clientList = await self.clients.matchAll({
          type: 'window',
          includeUncontrolled: true
        })
        
        console.log('ðŸ‘¥ Found clients:', clientList.length)
        
        // Check if a window with the app is already open
        for (const client of clientList) {
          const clientUrl = new URL(client.url)
          const targetUrl = new URL(urlToOpen, self.location.origin)
          
          console.log('ðŸ” Checking client:', client.url)
          
          // If we find an open window with our app, focus it and navigate
          if (clientUrl.origin === targetUrl.origin) {
            console.log('ðŸ“± Focusing existing window and navigating')
            
            // Navigate the client to the target URL
            if ('navigate' in client) {
              await (client as any).navigate(targetUrl.href)
            }
            
            // Focus the window
            if ('focus' in client) {
              return client.focus()
            }
          }
        }
        
        // If no matching window, open a new one
        if (self.clients.openWindow) {
          const fullUrl = new URL(urlToOpen, self.location.origin).href
          console.log('ðŸ†• Opening new window:', fullUrl)
          return self.clients.openWindow(fullUrl)
        }
      } catch (error) {
        console.error('âŒ Error handling notification click:', error)
      }
    })()
  )
})

// Listen for notification close events (user dismissed it)
self.addEventListener('notificationclose', (event: NotificationEvent) => {
  console.log('ðŸ”• Notification dismissed:', event.notification.tag)
  // Optional: Track dismissal analytics here
})

// Handle service worker activation
self.addEventListener('activate', (event) => {
  console.log('âœ… Service worker activated')
  event.waitUntil(self.clients.claim())
})

// Handle service worker installation
self.addEventListener('install', () => {
  console.log('ðŸ“¦ Service worker installing')
  self.skipWaiting()
})
